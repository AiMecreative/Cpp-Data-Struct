# 外部归并排序

## 封装思路

- 缓冲区模块 `Buffer`
  - 主要是对 `vector` 再次封装, 换个名字, 本质还是调用STL
  - 用来创建相应大小的buffer, 包括 `input`, `output`, `middle`
  - `middle`用来给后续的排序
- 缓冲区输入输出 `BUfferIO`
  - 继承 `Buffer`, 负责面向文件的读写
- 生成器 `Generator`
  - 生成随机数据
  - 默认生成归并段
  - 败者树生成归并段
- 排序函数 `SortFunc`
  - 默认的选择排序 `defaultCompare` , 选最小即可
    - 参数1: `Buffer` 表示排序所使用的空间
    - 参数2: `vector` 表示输入的, 当前轮次待比较的序列, 大小为归并段的数目
    - 返回: 为当前较小元素的 `index`
  - 败者树排序 `loserTree` , 根据败者树来排序, 由于既要用来生成归并段, 又要用于排序, 所以把 `LoserTree` 重新封装为一个类, 生成和排序分别封装为函数
    - 参数1: `Buffer` 表示排序所使用的空间, **应该是存放整个树的大小**
    - 参数2: `vector` 表示当前轮次待比较的, 输入的归并段的首个元素, 大小为归并段的数目
    - 返回: 为当前较小元素的 `index`
- 败者树 `LoserTree`
  - //TODO
- 归并排序 `MergeSort`
  - 封装一些比较方便调用的方法

### 问题

Q1. **怎么封装多线程?**

不知道加入多线程以后会不会对当前的结构产生影响, 不过想了一下, 多线程只是实现了对函数在不同时刻的调用

比如线程1用来给败者树, 线程2给input1和input2, 线程3给output1和output2

```text
t2 in i1 ---> t1 in i1 ---> t3 in o1 ---> t1 in i2
         |             |
         |--> t2 in i2 + -> t2 in i1
```

